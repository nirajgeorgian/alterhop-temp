{"version":3,"sources":["../../src/controller/auth.controller.js"],"names":["signup","req","res","data","body","UserModel","findOne","$or","email","username","oldUser","status","send","user","hashPassword","save","login","verified","verifyPassword","password","token","jwt","sign","id","process","env","JWT_SECRET","expiresIn"],"mappings":";;;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;AACA;;;;;;AAEO,IAAMA;AAAA,oEAAS,iBAAOC,GAAP,EAAYC,GAAZ;AAAA;AAAA;AAAA;AAAA;AAAA;AACfC,UADe,GACRF,IAAIG,IADI;AAAA;AAAA,aAECC,eAAUC,OAAV,CAAkB,EAAEC,KAAK,CAAC,EAACC,OAAOL,KAAKK,KAAb,EAAD,EAAsB,EAAEC,UAAUN,KAAKM,QAAjB,EAAtB,CAAP,EAAlB,CAFD;;AAAA;AAEfC,aAFe;;AAAA,WAGlBA,OAHkB;AAAA;AAAA;AAAA;;AAAA,uCAIbR,IAAIS,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,wBAAS,KAAT,EAAgB,2BAAhB,CAArB,CAJa;;AAAA;AAMfC,UANe,GAMR,IAAIR,cAAJ,CAAcF,IAAd,CANQ;;AAOrBU,WAAKC,YAAL;AAPqB;AAAA,aAQfD,KAAKE,IAAL,EARe;;AAAA;AAAA,uCASdb,IAAIS,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,wBAAS,IAAT,EAAeC,IAAf,CAArB,CATc;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAT;;AAAA;AAAA;AAAA;AAAA,GAAN;;AAYA,IAAMG;AAAA,qEAAQ,kBAAOf,GAAP,EAAYC,GAAZ;AAAA;AAAA;AAAA;AAAA;AAAA;AACdC,UADc,GACPF,IAAIG,IADG;AAAA;AAAA,aAEDC,eAAUC,OAAV,CAAkB,EAAEG,UAAUN,KAAKM,QAAjB,EAAlB,CAFC;;AAAA;AAEdI,UAFc;;AAAA,UAGhBA,IAHgB;AAAA;AAAA;AAAA;;AAAA;AAAA,aAINX,IAAIS,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,wBAAS,KAAT,4BAAuCT,KAAKM,QAA5C,CAArB,CAJM;;AAAA;AAAA;;AAAA;AAMdQ,cANc,GAMHJ,KAAKK,cAAL,CAAoBf,KAAKgB,QAAzB,CANG;;AAAA,UAOhBF,QAPgB;AAAA;AAAA;AAAA;;AAAA,wCAQZf,IAAIS,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,wBAAS,KAAT,6CAAyDT,KAAKgB,QAA9D,CAArB,CARY;;AAAA;AAUdC,WAVc,GAUNC,uBAAIC,IAAJ,CAAS;AACtBC,WAAIV,KAAKU,EADa;AAEtBf,cAAOK,KAAKL,KAFU;AAGtBC,iBAAUI,KAAKJ;AAHO,OAAT,EAIXe,QAAQC,GAAR,CAAYC,UAJD,EAIa,EAAEC,WAAW,IAAb,EAJb,CAVM;AAAA,wCAebzB,IAAIS,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,wBAAS,IAAT,EAAeQ,KAAf,CAArB,CAfa;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAR;;AAAA;AAAA;AAAA;AAAA,GAAN;;AAkBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"auth.controller.js","sourcesContent":["import jwt from 'jsonwebtoken'\nimport UserModel from '../models/user.model'\nimport response from '../util/response.response'\nimport { generateToken } from '../util/tokenGenerate'\nimport { getAsync } from '../util/redis.util'\n\nexport const signup = async (req, res) => {\n\tconst data = req.body\n\tconst oldUser = await UserModel.findOne({ $or: [{email: data.email}, { username: data.username}]})\n\tif(oldUser) {\n\t\treturn res.status(401).send(response(false, \"error user already exists\"))\n\t}\n\tconst user = new UserModel(data)\n\tuser.hashPassword()\n\tawait user.save()\n\treturn res.status(201).send(response(true, user))\n}\n\nexport const login = async (req, res) => {\n\tconst data = req.body\n\tconst user = await UserModel.findOne({ username: data.username })\n\tif(!user) {\n\t\treturn await res.status(401).send(response(false, `No User exist's for ${data.username}`))\n\t}\n\tconst verified = user.verifyPassword(data.password)\n\tif(!verified) {\n\t\treturn res.status(401).send(response(false, `Sorry the password did not matched:=> ${data.password}`))\n\t}\n\tconst token = jwt.sign({\n\t\tid: user.id,\n\t\temail: user.email,\n\t\tusername: user.username\n\t}, process.env.JWT_SECRET, { expiresIn: '1h' })\n\treturn res.status(200).send(response(true, token))\n}\n\n// const passwordToken = async (req, res) => {\n// \tconst data = req.body\n// \tconst email = data.email ? data.email : ''\n// \tconst username = data.username ? data.username : ''\n// \tconst user = await UserModel.findOne({ $or: [{ email: email }, { username: username }]})\n// \tif(!user) {\n// \t\tif(email === '' && username === '') {\n// \t\t\treturn res.status(401).send(response(false, `Please pass email or username`))\n// \t\t}\n// \t\tif(email !== '') {\n// \t\t\treturn res.status(401).send(response(false, `no user exist for this ${email}`))\n// \t\t}\n// \t\tif(username !== '') {\n// \t\t\treturn res.status(401).send(response(false, `no user exist for this ${username}`))\n// \t\t}\n// \t}\n// \tconst token = generateToken(50)\n// \tif(email !== '') {\n// \t\tredisClient.set(`${email}-password-reset`, token, redis.print)\n// \t}\n// \tif(username !== '') {\n// \t\tredisClient.set(`${username}-password-reset`, token, redis.print)\n// \t}\n// \treturn res.status(200).send(response(true, token))\n// }\n//\n//\n// /**\n//  * @params { token, username, email }\n//  * @return { success, message }\n//  * Mutation to confirm password reset token and generate token for updating password\n//  */\n// const confirmToken = async (_, { input }, { redisClient, getAsync }) => {\n// \tconst data = req.body\n// \tconst token = data.token\n// \tconst email = data.email ? data.email : ''\n// \tconst username = data.username ? data.username : ''\n// \tlet key = null\n// \tif(email !== '') {\n// \t\tkey = `${email}-password-reset`\n// \t}\n// \tif(username !== '') {\n// \t\tkey = `${username}-password-reset`\n// \t}\n// \tif(key !== null) {\n// \t\tconst isKey = redisClient.get(key, redis.print)\n// \t\tif(!isKey) {\n// \t\t\treturn res.status(401).send(response(false, `no value for provider key`))\n// \t\t}\n// \t}\n// \tconst user = await User.findOne({$or: [{ email: email }, { username: username }]})\n// \tif(!user) {\n// \t\tif(email === '' && username === '') {\n// \t\t\treturn res.status(401).send(response(false, `Please pass email or username`))\n// \t\t}\n// \t\tif(email !== '') {\n// \t\t\treturn res.status(401).send(response(false, `no user exist for this ${email}`))\n// \t\t}\n// \t\tif(username !== '') {\n// \t\t\treturn res.status(401).send(response(false, `no user exist for this ${username}`))\n// \t\t}\n// \t}\n// \tconst datat = await getAsync(key)\n// \tif(datat !== token || datat === null) {\n// \t\treturn res.status(401).send(response(false, `Please pass valid token`))\n// \t}\n// \t// data is equal to token\n// \tredisClient.del(key)\n// \tconst newToken = generateToken(50)\n// \tif(email !== '') {\n// \t\tredisClient.set(`${email}-password-token`, newToken, redis.print)\n// \t}\n// \tif(username !== '') {\n// \t\tredisClient.set(`${username}-password-token`, newToken, redis.print)\n// \t}\n// \treturn res.status(200).send(response(true, newToken))\n// }\n//\n//\n// /**\n//  * @params { token, againPassword, password }\n//  * @return { success, message }\n//  * Mutation to confirm reset password with token\n//  */\n// const resetPassword = async (_, { input }, { redisClient, getAsync }) => {\n// \tconst data = req.body\n// \tconst token = data.token\n// \tconst email = data.email ? data.email : ''\n// \tconst username = data.username ? data.username : ''\n// \tlet key = null\n// \tif(email !== '') {\n// \t\tkey = `${email}-password-token`\n// \t}\n// \tif(username !== '') {\n// \t\tkey = `${username}-password-token`\n// \t}\n// \tconst user = await User.findOne({$or: [{ email: email }, { username: username }]})\n// \tif(!user) {\n// \t\tif(email === '' && username === '') {\n// \t\t\treturn res.status(401).send(response(false, `Please pass email or username`))\n// \t\t}\n// \t\tif(email !== '') {\n// \t\t\treturn res.status(401).send(response(false, `no user exist for this ${email}`))\n// \t\t}\n// \t\tif(username !== '') {\n// \t\t\treturn res.status(401).send(response(false, `no user exist for this ${username}`))\n// \t\t}\n// \t}\n// \tconst datat = await getAsync(key)\n// \tif(datat !== token || datat === null) {\n// \t\treturn res.status(401).send(response(false, `Please pass valid token`))\n// \t}\n// \tif(data.password !== data.againPassword) {\n// \t\treturn res.status(401).send(response(false, `Wrong password match`))\n// \t}\n// \tuser.password = data.password\n// \tuser.hashPassword()\n// \tawait user.save()\n// \tredisClient.del(key)\n// \treturn res.status(200).send(response(true, \"Successfully updated password\"))\n// }\n"]}